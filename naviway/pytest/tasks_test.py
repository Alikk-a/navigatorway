"""
Тестовые файлы должны быть названы test_<something>.py или <something>_test.py.
Методы и функции тестирования должны быть названы test_<something>.
Тестовые классы должны быть названы Test<Something>

запуск конкретного теста в конкретном файле. можно указывать несколько файлов/каталогов/тестов через пробел
pytest navigator/pytest/tasks_test.py::test_member_access metriktrd_project/pytest/task_test.py::test_asdict
опции
--collect-only только собирать тесты, не выполнять их. ПОКАЗЫВАЕТ список всех тестов

-k ВЫРАЖЕНИЕ       запускать только те тесты, которые соответствуют заданной подстроке
                    Пример:
                        -k 'test_method or test_other' соответствует всем тестам
                        функции и классы, имя которых содержит
                        'test_method' или 'test_other', а -k 'not test_method' соответствует тем, которые не содержат
                        'test_method' в их именах.
-m MARKEXPR        запускает только тесты, соответствующие заданному выражению метки.
                   pytest -m run_these_please -v (такой декоратор есть)
                   Выражение маркера не обязательно должно быть одним маркером. Вы можете использовать такие варианты,
                   как -m "mark1 and mark2" для тестов с обоими маркерами, -m "mark1 and not mark2" для тестов,
                   которые имеют метку 1, но не метку 2, -m "mark1 or mark2" для тестов с одним из и т. д.
-x, --exitfirst    прекращает тестирование при первой ошибке теста - на начальном этапе экономит время на отладке
--maxfail=число    Параметр -x приводит к остановке после первого отказа теста. Если вы хотите, чтобы некоторые число сбоев было допущено,
                    но не целая тонна, используйте параметр --maxfail, чтобы указать, сколько ошибок допускается получить.

-s и --capture=метод    Флаг -s позволяет печатать операторы — или любой другой вывод, который обычно печатается в stdout,
                        чтобы фактически быть напечатаным в стандартном выводе во время выполнения тестов. Это сокращенный вариант для --capture=no.
                        Смысл в том, что обычно выходные данные захватываются во всех тестах. Неудачные тесты будут выводиться после того, как тест
                        будет протекать в предположении, что выход поможет вам понять, что что то пошло не так. Параметр -s или --capture=no отключает
                        захват выходных данных. При разработке тестов я обычно добавляю несколько операторов print(), чтобы можно было следить за ходом теста.

-lf, --last--failed     При сбое одного или нескольких тестов способ выполнения только неудачных тестов полезен для отладки.
                        Выполнит только последние сбойные тесты, остальные не будет
                        –ff, --failed-first  Параметр  будет делать то же самое, что и --last-failed, а затем выполнять остальные тесты, прошедшие в прошлый раз:

v, --verbose увеличить детализацию - выводит списком прохождение тестов и другое
-q, --quiet уменьшить многословие.
--verbosity=VERBOSE установить многословие

-l, --showlocals  При использовании параметра -l/--showlocals локальные переменные и их значения отображаются вместе с tracebacks для неудачных тестов.

--tb=style  изменяет способ вывода пакетов трассировки для сбоев. При сбое теста pytest отображает список сбоев
            и так называемую обратную трассировку, которая показывает точную строку, в которой произошел сбой.

--durations=N   невероятно полезна, когда вы пытаетесь ускорить свой набор тестов. Она не меняет ваши тесты; сообщает самый медленный N номер
                tests/setups/teardowns по окончании тестов. Если вы передадите --durations=0, он сообщит обо всем в порядке от самого медленного к самому быстрому.


отладка и настройка тестовой сессии:
--basetemp=dir базовый временный каталог для этого тестового запуска. (предупреждение: этот каталог удаляется, если он существует)
--version отображать версию pytest lib и информацию об импорте.
-h, --help показать справочное сообщение и информацию о конфигурации

-------------------------------------------------------------------
для примера - Проверим тип данных Task (ниже).
"""

from collections import namedtuple
import pytest
# from django.contrib.auth.models import User

Task = namedtuple('Task', ['summary', 'owner', 'done', 'id'])
Task.__new__.__defaults__ = (None, None, False, None)


def test_defaults():
    """Без использования параметров, следует ссылаться на значения по умолчанию."""
    t1 = Task()
    t2 = Task(None, None, False, None)
    assert t1 == t2


""" декоратор ниже - это маркер, можно запускать выборочно тесты, но нужно регистрировать маркеры, иначе выдает предупреждения (но все арвно работает)"""


# @pytest.mark.run_these_please
def test_asdict(person):
    """_asdict() должен возвращать словарь."""
    t_task = Task('do something', 'okken', True, 21)
    t_dict = t_task._asdict()
    expected = {'summary': 'do something',
                'owner': 'okken',
                'done': True,
                'id': 21}
    assert t_dict == expected


@pytest.mark.usefixtures('print_hello')  # параметр здесь - фикстура для всего класса
class TestSomething:
    def test_member_access(self,
                           data_1):  # в параметрах указаны фикстуры, которые выполняются ДО - они в файле conftest.py (нахоит файл в этом каталоге и ПОДкаталогах автоматически
        """Проверка свойства .field (поля) namedtuple."""
        t = Task('buy milk', 'brian')
        assert t.summary == 'buy milk'
        assert t.owner == 'brian'
        assert (t.done, t.id) == (False, None)

    def test_replace(self):
        """должно изменить переданное в fields."""
        t_before = Task('finish book', 'brian', False)
        t_after = t_before._replace(id=10, done=True)
        t_expected = Task('finish book', 'brian', True, 10)
        assert t_after == t_expected


# @pytest.mark.django_db
# def test_my_user():
#     me = User.objects.get(username='Ali')
#     assert me.is_superuser